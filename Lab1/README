这里是日志，大家可以记录
2021/3/19--LHZ
成功通过线程减小了运行时间，但是并发还没有做到，之后解决线程间的临界区访问问题；
先完成一个100M内文件的数独问题
之后再拓展为任意大小
2021/3/19--LHZ
利用links函数“每次会将一个数独问题保留在类中”的特点，解决了多线程的临界问题
之后用solve()函数进行验证，答案无误
现在主要解决
1、如何进一步提升性能（考虑用cache算法，或者优化link算法，或者对主题部分进行优化）
2、如何读入任意大小的问题
2021/3/19--LHZ
和往届学长学姐进行对比后发现，算法还有很多不足，尤其需要解决粗粒度锁的问题
0.1s的瓶颈也是一个问题，如果能降低复杂度，可能需要再考虑考虑
2021/3/20--LHZ
经过将new操作提前分配，将解题时间下限减小至0.04s，可以算是一个突破了
2021/3/21--LHZ
收到SW算法的启示，使用缓存将结果暂存，并实现按顺序输出答案。
同时，并每隔一个固定大小的输入，就进行线程同步，实现任意大小的文件处理。
LAB1基础版本无误，并更新至master，此版本非linux。
2021/3/22--ZZQ
根据前面并发运算输出得到的结果进行验证，编写程序验证结果输出正确并且顺序正确，验证程序已上传
2021/3/24--LHZ
编写了makefile文件后，满足了实验要求。遇到了一些问题，因为虚拟机上的内存大小较小
所以一旦开的线程数较多，会出现segment fault，所以减小原始线程数。
之后优化可以参考CPU-affmity，sched_yield()。
2021/3/26--LHZ
两个线程读取可以使用锁+信号量实现
2021/3/27--ZJJ
对接受任意数字的输入进行了最基本的改写，但是还没有建立线程完成这项任务，还没有和之前的代码整合。
2021/3/28--ZJJ
和代码整合了，能够通过make形成可执行文件，接受任意多个输出，但还不是独立线程处理
学习了用git创建分支和正确的提交的步骤和方法
2021/3/31--LHZ
之前讨论的一种优化方法，将结果正确检测函数solve()放在每一个线程中运行。
2021/4/3--LHZ
进过测试，创建一个线程进行读取会存在很多问题，首先是输入流会被输出流打断
所以可以考虑同步接收或者，对输入输出进行控制
2021/4/5--LHZ
发现了一个很严重的BUG，在程序多次运行后会出现SEGMENT FAULT
起初以为是程序线程没有释放，最后再高级版本中发现多次输入也会导致这个问题
2021/4/5--LHZ
解决了，又是那个*arg的问题，不小心把它给释放了
我寻思着，我都释放了，程序居然还能跑对好几个？C++对程序员要求太高了
2021/4/6--ZJJ
学习了shell脚本的有关知识。借鉴学长的代码，尝试使用shell代替人工进行多输入文件代码正确性的测试
以及尝试使用python中的工具进行绘图
2021/4/8--LHZ
增加了线程亲和性，使用pthread_setaffinity_np函数绑定CPU
其实要真正发挥CPU的性能，应该先进行CPU隔离，在进行CPU绑定，但是我不会CPU隔离
因为那样好麻烦，还要重启虚拟机，懒
希望性能会有提高
2021/4/9--LHZ
今天进行展示，很满意！

